# 第 1 章 引言

### 設計模式的作用是什麼？

設計物件導軟體向比較困難，而設計可複用的物件導向程式就更加困難：

- 程式的粒度
- 程式的歸類
- 介面和繼承的關係
- 物件之間的關係
- 同時對將來隨時間衍生的需求也要有足夠的通用性


有經驗的物件導向設計者會告訴你，  
要一下子就得到復用性和靈活性好設計，並非不可能，但至少也是非常困難的。  
**一個設計在最終完成之前常要被復用好幾次，而且每一次都有所修改。**

有經驗的開發人員設計者知道不是解決任何問題都要從頭做起，
他們更願意使用以前使用過的解決方案（設計）。

一個好的解決方案會被一遍又一遍地使用，
因此你會在許多物件導向系統中看到**物件之間重複出現的協作模式**。

這些設計模式解決了特定的設計問題，使物件導向更容易擴展、閱讀、維護。

## 到處都有模式

小說家很少從頭開始設計劇情，總是沿襲已經存在的模式，例如：

- 悲劇性英雄模式
- 浪漫小說模式

同樣地，開發人員也沿襲了一些模式，例如：

- 使用物件來表達資料的狀態
- 設計物件的公開方法，維護資料（添加/刪除屬性）

這本書的目的就是將面向對象軟件的設計經驗作為設計式記錄下來，  
替每一個設計模式系統地命名、解釋、分類。

設計模式使人們可以更加容易地複用成功的設計和結構。  
**將已證實的技術表述成設計模式，也會使新系統開發者更加容易理解其設計思路**

```
例如：
Cache 快取、隊列 Queue、前端的 Lazy Loading
```

書中討論的設計式僅僅包含一些物件導向的模式。  
書中沒有討論與分布式系統、即時系統相關的設計模式，也沒有收錄特定領域的模式。  
所以本書不會教你怎麼打造 UI 介面，怎麼寫設備驅動程式，或怎麼使用資料庫。  
每個領域都有自己的模式，將這些模式分類編目也是相當有意義的事情。

```
備註：
不是只有物件導向才有設計模式，
事實上，到處都有設計模式
而這本書提到的模式並非只能透過物件導向來實現。

希望各位閱讀這本書時，不要緊抓著每一個模式的「實作內容」不放。

焦點放在每一個模式的「實作內容」很容易使你在學習設計模式中撞牆，
因為一個模式在不同的場景下，就可能有不同的實作內容跟方法，
唯一不會變動的事每一個模式的「意圖」，包含：
  - 想解決什麼問題
  - 基本原理是什麼
```

## 1.1 什麼是設計模式

Christopher Alexander 說過:  
> “ 每一個模式描述了一個在我們周圍不斷重複發生的問題，以及該問題的解決方案的核心。  
> 這樣，你就能一次又一次地使用該方案而不必做重複勞動 “

儘管 Alexander 所指的是城市和建築模式，但他的思想也同樣適用於物件導向設計模式，  
只在物件導向的解決方案裡，我們用物件和介面代替了牆壁和門窗。

一般而言，一個模式有四個基本要素:

1. 模式名稱 (pattem name)  
一個助記名，允許我們在較高的抽象層次上進行其他人交流。

2. 問題 (problem)  
解釋了設計問題和問題存在的前因後果，  
它可能描述了特定的設計問題，如怎樣使用物件表示演算法等、  
也可能描述了**導致不靈活設計**的程式結構。

3. 解決方案 (solution)  
描述了設計的組成成分，以及它們之間的**互相關係**及**各自的職責**和**協作方式**。  
因為模式就像一個範本，可應用於種不同場合，  
所以**解決方案並不描述一個特定而具體的設計或實現**，  
**而提供設計問題的抽象描述，和怎樣用具有意義的元素組合來解決問題**。

4. 效果 (consequences)  
描述了模式的效果與 **權衡**。  
引入每一個模式都有成本，增加一些理解的複雜度，  
以換取對系統的「靈活性、擴充性或可移植性」，  
使用模式之前，慎重考慮上述這些影響與權衡將會很有幫助。

## 1.2 MVC 模式

https://imgur.com/a/f72DLcz

MVC 通過建立一個 “訂閱/通知” 結構來分離**視圖（View）**和**模型（Model）**。  
**視圖** 必須保證它的顯示正確地反映了 **模型** 的狀態。  
一旦模型的數據發生變化模型將通知有關的視圖，每個視圖將得到更新自己的機會。  
這種方法可以讓你為一個**模型**提供**多個不同的視圖**表現形式，也能夠在**創建新的視圖而無須重寫模型**。

## 1.3 描述設計模式

我們怎樣描述設計模式呢？  
**圖形符號雖然很重要也很有用，卻還遠遠不夠**，  
它們只是將設計過程的結果簡單記錄為類和對象之間的關係。

為了達到設計復用，  
我們**必須同時記錄設計產生的決定過程、選擇過程和權衡過程**，  
具體的例子也是很重要的，它們讓你看到實際的設計。

### 範例：
原本使用的第三方信件服務開始收費了，為了節省使用寄信費用支出，故在送出信件前檢查信件格式。

這個範例紀錄了 **一個功能會在不同的時空背景下有不同的需求規格**，  
我們有責任記錄下為什麼要在某個時間點引入模式來解決問題，  
讓後續維護的人能理解模式的用意。

- commit: [tests:[第1章]新增 EmailSender::send 寄送信件服務](https://github.com/WadeHuang1993/design_pattern_book_club/commit/08b65bbfd9b9066af35037aa92e7b335c458fe08)
- commit: [tests:[第1章]因應第三方寄信服務開始收費，調整 EmailSender 邏輯](https://github.com/WadeHuang1993/design_pattern_book_club/commit/2e10efea8bcd5915cab69a47aa407b32f90d4236)

另外，從這個案例也可以觀察到設計模式並非只能應用在「物件層級」，  
這個 Proxy 模式其實也是微服務層級的代理模式，  
透過這個 Proxy 管理了我方服務與 Gmail 服務之間的存取方式。

## 1.4 設計模式目錄

這一小節只是列出所有模式的意圖，故先略過。

## 1.5 設計模式分類

https://imgur.com/a/IZpJ3St

設計模式依據其目的可分為：

- 創建型模式（Creational）： 與物件的創建過程有關
- 結構型模式（Structural）： 處理類別和物件的組合
- 行為型模式（Behavioral）： 處理類別或物件如何交互與分配職責

創建型類別模式將物件的部分創建工作延遲到子類，而創建型物件模式則將他延遲到另一個物件中。  
結構型類別模式使用繼承機制來組合類，而結構型物件模式則描述了物件的組裝方式。  
行為型類別模式使用繼承描述演算法和控制流，而行為型物件模式則描述一組物件怎樣協作完成單個物件所無法完成的任務。

另外，有些模式經常會綁在一起使用；也有模式是可以互相替換的

## 1.6 設計模式怎麼如何「設計」的問題？

### 1.6.1 幫助開發人員找出適合的物件

面向對象設計最困難的部分是將系統分解成對象集合，因為要考慮許多因素：

- 封裝
- 粒度
- 依賴關係
- 靈活性
- 性能
- 演化
- 重複使用 ..等等

它們都影響著系統的分解，並且這些因素通常還是互相衝突的。

設計模式幫你定並不明顯的抽象和述這些抽象的對象例如，  
描述過程或算法的對象現實中並不存在但它們卻設計的關鍵部分。

Strategy 模式描述了怎樣實現可互換的演算法。  
State 模式將實體的每個狀態描述為一個對象。  
這些對像**在分析階段、甚至在設計階段的期都並不存在**，  
後來為使設計更靈活、復用性更好才將它們發掘出來。

```
備註：
因應需求變化並且不斷地重構逐漸引入模式，而不是一開始就引入模式。
```

### 範例：購物車新增免運規則，購買特定商品就直接免運

原本購物車需要購買滿 1000 元才有免運，  
但是因應這次活動，只需要購買任一個「聖誕節禮品」即免運。

- commit: [feat:[第1章]1.6.1 範例：購物車免運](https://github.com/WadeHuang1993/design_pattern_book_club/commit/645ac623470ef3193d2462b5dcec140aa5208271)
- commit: [refactor:[第1章]1.6.1 封裝購物車計算運費的演算法](https://github.com/WadeHuang1993/design_pattern_book_club/commit/5243260b9e81ef2e291ee79f3d226011dd59c142)
- commit: [refactor:[第1章]1.6.1 擴充購物車免運邏輯，聖誕夜購買任一個「聖誕節禮品」即免運](https://github.com/WadeHuang1993/design_pattern_book_club/commit/2768e207fb59e75706375efe16d4b5a551b529fa)

從這次的範例中，我們可以看到設計模式並不是系統一開始就引入的，  
而是隨著時間和需求增長，且持續重構慢慢引入的。

另外，熟悉設計模式的話，也會讓開發人員得到一種「感知」。  
例如在 commit: [refactor:[第1章]1.6.1 封裝購物車計算運費的演算法](https://github.com/WadeHuang1993/design_pattern_book_club/commit/5243260b9e81ef2e291ee79f3d226011dd59c142) 中，  
開發人員感知運費其實相當容易變動，故事先調整程式碼的結構來應對未來的變化。  
這也呼應了序章 Grady Booch 提及的 [設計模式提供新的視角](https://github.com/WadeHuang1993/design_pattern_book_club/tree/main/0.%20%E5%BA%8F%E8%A8%80#%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%96%B0%E7%9A%84%E8%A6%96%E8%A7%92)。



### 1.6.2 管理物件的粒度

對像在大小和數目上變化極大。它們能表示任何事物。  
那麼我們怎樣決定一個物件應該是什麼呢？  
設計模式很好地講述了這個問題。  
Facade 模式描述了用物件表示完整的子系統; Flyweight 模式描述瞭如何支援大量的最小粒度的對像。  
其他一些設計式描述了將一個物件分解成許多小物件的特定方法。  

### 1.6.3 指定物件的介面

1.6.3 ~ 1.6.6 可以看  
@link https://wadehuang1993.github.io/blog/design_patterns_interface_and_type_is_important/

### 1.6.7 設計應該支持變化

獲得最大限度重複使用的關鍵在於對新需求和舊需求發生變化時的預見性，  
你的系統設計要能夠相應地改進。

為了設計適應這種變化、具有健壯性的系統，  
你必須思考系統在生命週期中會發生怎樣的變化。

一個不考慮系統變化的設計，在將來就有可能需要重新設計。  
這些變化可能是介面的重新定義和實現、並且需要重新測試。

下面闡述了一些導致重新設計的一般原因，以及解決這些問題設計模式：

```
備註：
下面 8 項很好的重構指南，很適合回頭檢視自己的系統是不是可以優化了
```

#### 1.  **顯式地指定一個類來創建對像在創建物件**
指定類別名將**使系統受到特定實現的約東，而不是特定介面的約東**。  
這**會限制未來的變化的靈活性**，也會造成系統依賴的混亂。  
要避免這種情況，應該間接地創建物件。  
設計模式：Abstract Factory (3.1),Factory Method (3.3), Prototype (3.4).

購物車運費範例（重構前）：
<img width="800" alt="image" src="https://user-images.githubusercontent.com/61677399/201600439-e8d92a6f-7dad-4c55-b67f-ef8bfc77430a.png">

購物車運費範例（重構後）：  
<img width="786" alt="image" src="https://user-images.githubusercontent.com/61677399/201600659-aebfa2dd-3475-46bc-8c31-84632fd749a7.png">  
<img width="863" alt="image" src="https://user-images.githubusercontent.com/61677399/201600898-e85e31e2-ee5d-4a96-a3eb-8ab733d668ac.png">


#### 2. **對特殊操作的依賴**
當你為請求指定―個特殊的操作時，完成該請求的方式就固定下來了。  
為避免把求代碼寫死，你將**可以在編譯時刻或運行時刻很方便地改變響應求的方法**。  
設計模式：Chain of Resposibility (5.1),Command (5.2)。

購物車範例：
![image](https://user-images.githubusercontent.com/61677399/201588254-9aa9e105-545f-480d-ba6e-d7acf442649a.png)

購物車重構前：
https://github.com/WadeHuang1993/design_pattern_book_club/pull/7/commits/5c0495746d6642608d626881c0fa3d8869b24b97#diff-886c2ba55a1f1d7a21d9a53bbba1a75398bf961297c95874d2471836f36552de

購物車重構後：
<img width="1135" alt="image" src="https://user-images.githubusercontent.com/61677399/201566011-911f4f3b-67dc-4d97-b694-46ac9d7a1ba2.png">


#### 3. **對硬體和軟件平台的依賴**
外部的 **操作系統介面** 和**應用編程介面 (API)** 在不同的軟硬體平台上是不同的。  
依賴於特定台的軟件將很難移植到其他平上，  
甚至都很難跟上本地平台的更新。  
所以設計系統時限制其平台相關性就很重要了。  
設計模式：Abstract Factory (3.1),Bridge (4.2),

#### 4. 物件表示或實現的依賴
知道物件怎表示、保存、定位或實現的客戶在物件發生變化時可能也需要變化。  
對客戶隱藏這些資訊能阻連鎖變化。    
設計模式：Abstract Factory (3.1),Bridge (4,2), Memento (5.6), Proxy (4.7)

#### 5. 演算法依賴
演算法在開發和復用時常常被擴展、優化和替代。  
依賴於某個特定演算法的物件在使得系統在演算法發生變化時不得跟著不變化。  
因此將**可能發生變化的演算法應單獨封裝起來**  
設計模式: Builder (3.2), Iterator (5.4), Strategy (5.9), Template Method (5.10),
Visitor (5.11)

<img width="848" alt="image" src="https://user-images.githubusercontent.com/61677399/201615199-e924fc85-7e57-4bbc-aa2b-450dcb91f120.png">
<img width="839" alt="image" src="https://user-images.githubusercontent.com/61677399/201615461-882ab67f-fbff-4523-8ae3-a6d7e82a745a.png">

#### 6. 緊藕合
緊合的類很難獨立地被復用，因為它們互相依賴的。  
緊合產生單塊的系統，要改變或刪掉一個類，你必須理解和改變其他許多類。  
這樣的系統是一個很難學習、移植和維護的密集體。  

鬆散合提高了一個類本身被復用的可能性，並且系統更易於學習、移植、修改和擴展。  
設計模式使用抽象合和分層技術來提高系統的鬆散藕合性。  
設計模式：Abstract Factory (3.1), Command (5.2), Facade (4.5), Mediator (5.5),
Observer (5.7) , Chain of Responsibility (5.1).

購物車重構前：
https://github.com/WadeHuang1993/design_pattern_book_club/pull/7/commits/5c0495746d6642608d626881c0fa3d8869b24b97#diff-886c2ba55a1f1d7a21d9a53bbba1a75398bf961297c95874d2471836f36552de

購物車重構後：
<img width="1135" alt="image" src="https://user-images.githubusercontent.com/61677399/201566011-911f4f3b-67dc-4d97-b694-46ac9d7a1ba2.png">


#### 7. 通過生成子類來擴充功能
 
1. 子類別中的實現與它的父類別有緊密的依賴關係，以至於父類別實現中的任何變化必然會導致子類別發生變化。
2.  因為繼承在編譯時期就定義了，所以無法在運行時刻改變從類別繼承的實現內容
3. 繼承下來的實現不適合解決新的問題，則父類必須重寫或被其他更適合的類替換。這種依賴關係限制了靈活性。

建議：
新的功能可以通過 **組合現有物件** 來重複使用實作內容，而不是通過繼承已存在的類別來達到重複使用實作內容的效果。 

另一方面，過多使用物件組合會使設計難於理解。  
許多設計模式產生的設計中，你可以定義一個子類，且將它的實例和已存在實例進行組合來引入定製的功能。  
設計模式：Bridge (4.2),Chain of Responsibility (5.1),Composite (4.3), Decorator (4.4),
Observer (5.7), Strategy (5.9).

#### 8. 不能方便地對類進行修改
有時你不得不改變一個難以修改的類。也許你需要源代碼，  
而沒有對於商業類庫就有這種情況，或者可能對類的任何改變會要求修改許多已存在的其他子類。  
設計模式提供在這些情況下對類進行修改的方法。  
設計模式：Adapter (4.1),Decorator (4.4), Visitor (5.11).

![image](https://user-images.githubusercontent.com/61677399/202082863-3e6dcef3-6b25-49b0-8fdf-041b7c1afcce.png)

## 1.7 怎樣選擇設計模式

這裡給出幾個不同的方法，幫助你發現適合你手頭問題的設計模式:

```
備註：  
章節 1.7 講的是如何利用這本書找出適合的設計模式。
```

### 1. 檢查設計模式是怎樣解決設計問題的

研究章節 1.6 的知識有助於幫助你找到合適的模式。

```
備註：
多了解物件導向的「封裝與抽象介面」使用時機與背後的思維，
有助於幫助我們適合的模式。
```

### 2. 瀏覽模式的意圖部分

**讀通每個模式的意圖**，找出可以解決當前設計問題的 1 個或多個模式。

### 3. 研究模式互相關聯 

圖 1-1 以圖形方式顯示了設計模式之的關係，能指導你找到合適的模式。


### 4. 研究目的相似的模式

模式類描述部共有三章
- 創建型模式
- 結構型模式
- 行為型模式
 
每一章都以對模式介紹和評價開始，  
接著再以多個一個小節的比較和對照作為結束。  
這些小節使你得以洞察具有相目的的模式之間的共同點和不同點。

```
備註：   
比較有沒有更適合用來解決當前設計問題的模式
```

### 5. 檢查重新設計的原因 

看一看從 “1.6.7 設計應支援變化” 小節討論的引起重新設計的各種原因，  
再看看你的問題是否與它們有關，然後再找出哪些模式可以幫助你避免這些會  
導致重新設計的因素。

```
備註：  
重新檢查設計模式的意圖有沒有辦法解決當前的設計問題
```

### 6. 檢查你的設計中哪些部分是可變動的

找出當前的設計問題中有哪些部分是容易變動的，  
將這些容易變動的部分封裝起來，確保每次變動時不會引起重新設計。  

這種 **封裝變化** 的概念，也是許多設計模式的主題。  

下表提供了每一個模式 **封裝變化** 的部分

<img width="942" alt="image" src="https://user-images.githubusercontent.com/61677399/202087298-12d102fa-78f7-4b8e-abbb-4f17532b9073.png">

## 1.8 怎樣使用設計模式

一旦你選擇了一個設計式，你怎麼使用它呢？  
這裡給出一個有效應用設計模式的循序漸進的方法。

### 1 大致瀏覽一遍模式

特別注意其適用性部和效果部分，確定它適合你得問題。

### 2 回頭研究結構部分參與者部分和協作部分

確保你理解這個模式的抽象介面和物件，以及它們是怎樣關聯的。

### 3 參考模式的原始碼實作範例

研究每一個模式的 **程式碼實作** 將有助於你實現模式。

### 4 選擇模式參與者的名字，使它們在程式碼的上下文中有意義

**設計模式參與者的名字通常過於抽象** 而不會直接出現在應用中。   
然而將參與者的名字和應用中出現得名字合併起來是很有用的。
這會幫助你在實現中更顯式的體現出模式來。  

例如，如果你在文字組合演算法中使用了 Strategy 模式，  
那麼你可能有名為 SimpleLayoutStrategy 或 TeXLayoutStrategy 這樣的類。

### 5 定義類別（Interface）

先宣告模式的介面，接著建立實作或繼承關係，
這有助於識別模式會影響到系統中的哪一些類別，並做出相應的修改。

### 6 定義模式中專用於應用的操作名稱

這裡再一次體現出，名字一般依賴於應用。  
使用與每一個操作相關聯的責任和協作作為指導。  
還有，你的**名字約定**要一致。  
例如，可以使用"Create” 前綴統一標記 Factory Method。

### 7) 實現執行模式中責任和協作的操作

這本書的實現部分提供一些線索指導你進行實現。  
程式碼示例部分的例子也能提供幫助。  
**但這些只對你一開始使用模式起指導作用。以後你會有自己的設計模式使用方法。**

關於設計模式，  
**如果不提一下它們的使用限制**，那麼關於怎樣使用它們的討論就不完整的。**

**設計模式不能夠隨意使用**。  
通常你通過**引入額外的間接層次**獲得靈活性和可變性的同時，  
你也**使設計變得更複雜或或犧牲了一定的性能**。  

一個設計模式只有當它提供的靈活性是真正需要的時候，才有必要使用。  
當衡量一個模式的得失時，它的效果部分是最能提供幫助的，如表 1-2 所示。

<img width="942" alt="image" src="https://user-images.githubusercontent.com/61677399/202087298-12d102fa-78f7-4b8e-abbb-4f17532b9073.png">


