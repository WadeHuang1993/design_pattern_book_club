# 第 1 章 引言

### 設計模式的作用是什麼？

設計物件導軟體向比較困難，而設計可複用的物件導向程式就更加困難：

- 程式的粒度
- 程式的歸類
- 介面和繼承的關係
- 物件之間的關係
- 同時對將來隨時間衍生的需求也要有足夠的通用性


有經驗的物件導向設計者會告訴你，
要一下子就得到復用性和靈活性好設計，並非不可能，但至少也是非常困難的。
**一個設計在最終完成之前常要被復用好幾次，而且每一次都有所修改。**

有經驗的開發人員設計者知道不是解決任何問題都要從頭做起，
他們更願意使用以前使用過的解決方案（設計）。

一個好的解決方案會被一遍又一遍地使用，
因此你會在許多物件導向系統中看到**物件之間重複出現的協作模式**。

這些設計模式解決了特定的設計問題，使物件導向更容易擴展、閱讀、維護。

## 到處都有模式

小說家很少從頭開始設計劇情，總是沿襲已經存在的模式，例如：

- 悲劇性英雄模式
- 浪漫小說模式

同樣地，開發人員也沿襲了一些模式，例如：

- 使用物件來表達資料的狀態
- 設計物件的公開方法，維護資料（添加/刪除屬性）

這本書的目的就是將面向對象軟件的設計經驗作為設計式記錄下來，
替每一個設計模式系統地命名、解釋、分類。

設計模式使人們可以更加容易地複用成功的設計和結構。
**將已證實的技術表述成設計模式，也會使新系統開發者更加容易理解其設計思路**

```
例如：
Cache 快取、隊列 Queue、前端的 Lazy Loading
```

書中討論的設計式僅僅包含一些物件導向的模式。
書中沒有討論與分布式系統、即時系統相關的設計模式，也沒有收錄特定領域的模式。
所以本書不會教你怎麼打造 UI 介面，怎麼寫設備驅動程式，或怎麼使用資料庫。
每個領域都有自己的模式，將這些模式分類編目也是相當有意義的事情。

```
備註：
不是只有物件導向才有設計模式，
事實上，到處都有設計模式
而這本書提到的模式並非只能透過物件導向來實現。

希望各位閱讀這本書時，不要緊抓著每一個模式的「實作內容」不放。

焦點放在每一個模式的「實作內容」很容易使你在學習設計模式中撞牆，
因為一個模式在不同的場景下，就可能有不同的實作內容跟方法，
唯一不會變動的事每一個模式的「意圖」，包含：
  - 想解決什麼問題
  - 基本原理是什麼
```

## 1.1 什麼是設計模式

Christopher Alexander 說過:
> “ 每一個模式描述了一個在我們周圍不斷重複發生的問題，以及該問題的解決方案的核心。
> 這樣，你就能一次又一次地使用該方案而不必做重複勞動 “

儘管 Alexander 所指的是城市和建築模式，但他的思想也同樣適用於物件導向設計模式，
只在物件導向的解決方案裡，我們用物件和介面代替了牆壁和門窗。

一般而言，一個模式有四個基本要素:

1. 模式名稱 (pattem name)
一個助記名，允許我們在較高的抽象層次上進行其他人交流。

2. 問題 (problem)
解釋了設計問題和問題存在的前因後果，
它可能描述了特定的設計問題，如怎樣使用物件表示演算法等、
也可能描述了**導致不靈活設計**的程式結構。

3. 解決方案 (solution)
描述了設計的組成成分，以及它們之間的**互相關係**及**各自的職責**和**協作方式**。
因為模式就像一個範本，可應用於種不同場合，
所以**解決方案並不描述一個特定而具體的設計或實現**，
**而提供設計問題的抽象描述，和怎樣用具有意義的元素組合來解決問題**。

4. 效果 (consequences)
描述了模式的效果與 **權衡**。
引入每一個模式都有成本，增加一些理解的複雜度，
以換取對系統的「靈活性、擴充性或可移植性」，
使用模式之前，慎重考慮上述這些影響與權衡將會很有幫助。

## 1.2 MVC 模式

https://imgur.com/a/f72DLcz

MVC 通過建立一個 “訂閱/通知” 結構來分離**視圖（View）**和**模型（Model）**。
**視圖** 必須保證它的顯示正確地反映了 **模型** 的狀態。
一旦模型的數據發生變化模型將通知有關的視圖，每個視圖將得到更新自己的機會。
這種方法可以讓你為一個**模型**提供**多個不同的視圖**表現形式，也能夠在**創建新的視圖而無須重寫模型**。

## 1.3 描述設計模式

我們怎樣描述設計模式呢？
**圖形符號雖然很重要也很有用，卻還遠遠不夠**，
它們只是將設計過程的結果簡單記錄為類和對象之間的關係。

為了達到設計復用，
我們**必須同時記錄設計產生的決定過程、選擇過程和權衡過程**，
具體的例子也是很重要的，它們讓你看到實際的設計。

### 範例：
原本使用的第三方信件服務開始收費了，為了節省使用寄信費用支出，故在送出信件前檢查信件格式。

這個範例紀錄了 **一個功能會在不同的時空背景下有不同的需求規格**，
我們有責任記錄下為什麼要在某個時間點引入模式來解決問題，
讓後續維護的人能理解模式的用意。

- commit: [tests:[第1章]新增 EmailSender::send 寄送信件服務](https://github.com/WadeHuang1993/design_pattern_book_club/commit/08b65bbfd9b9066af35037aa92e7b335c458fe08)
- commit: [tests:[第1章]因應第三方寄信服務開始收費，調整 EmailSender 邏輯](https://github.com/WadeHuang1993/design_pattern_book_club/commit/2e10efea8bcd5915cab69a47aa407b32f90d4236)

另外，從這個案例也可以觀察到設計模式並非只能應用在「物件層級」，
這個 Proxy 模式其實也是微服務層級的代理模式，
透過這個 Proxy 管理了我方服務與 Gmail 服務之間的存取方式。

## 1.4 設計模式目錄

這一小節只是列出所有模式的意圖，故先略過。

## 1.5 設計模式分類

https://imgur.com/a/IZpJ3St

設計模式依據其目的可分為：

- 創建型模式（Creational）： 與物件的創建過程有關
- 結構型模式（Structural）： 處理類別和物件的組合
- 行為型模式（Behavioral）： 處理類別或物件如何交互與分配職責

創建型類別模式將物件的部分創建工作延遲到子類，而創建型物件模式則將他延遲到另一個物件中。
結構型類別模式使用繼承機制來組合類，而結構型物件模式則描述了物件的組裝方式。
行為型類別模式使用繼承描述演算法和控制流，而行為型物件模式則描述一組物件怎樣協作完成單個物件所無法完成的任務。

另外，有些模式經常會綁在一起使用；也有模式是可以互相替換的

## 1.6 設計模式怎麼如何「設計」的問題？

### 1.6.1 幫助開發人員找出適合的物件

面向對象設計最困難的部分是將系統分解成對象集合，因為要考慮許多因素：

- 封裝
- 粒度
- 依賴關係
- 靈活性
- 性能
- 演化
- 重複使用 ..等等

它們都影響著系統的分解，並且這些因素通常還是互相衝突的。

設計模式幫你定並不明顯的抽象和述這些抽象的對象例如，
描述過程或算法的對象現實中並不存在但它們卻設計的關鍵部分。

Strategy 模式描述了怎樣實現可互換的演算法。
State 模式將實體的每個狀態描述為一個對象。
這些對像**在分析階段、甚至在設計階段的期都並不存在**，
後來為使設計更靈活、復用性更好才將它們發掘出來。

```
備註：
因應需求變化並且不斷地重構逐漸引入模式，而不是一開始就引入模式。
```

### 範例：購物車新增免運規則，購買特定商品就直接免運

原本購物車需要購買滿 1000 元才有免運，
但是因應這次活動，只需要購買任一個「聖誕節禮品」即免運。

- commit: [feat:[第1章]1.6.1 範例：購物車免運](https://github.com/WadeHuang1993/design_pattern_book_club/commit/645ac623470ef3193d2462b5dcec140aa5208271)
- commit: [refactor:[第1章]1.6.1 封裝購物車計算運費的演算法](https://github.com/WadeHuang1993/design_pattern_book_club/commit/5243260b9e81ef2e291ee79f3d226011dd59c142)
- commit: [refactor:[第1章]1.6.1 擴充購物車免運邏輯，聖誕夜購買任一個「聖誕節禮品」即免運](https://github.com/WadeHuang1993/design_pattern_book_club/commit/2768e207fb59e75706375efe16d4b5a551b529fa)

從這次的範例中，我們可以看到設計模式並不是系統一開始就引入的，
而是隨著時間和需求增長，且持續重構慢慢引入的。

另外，熟悉設計模式的話，也會讓開發人員得到一種「感知」。
例如在 commit: [refactor:[第1章]1.6.1 封裝購物車計算運費的演算法](https://github.com/WadeHuang1993/design_pattern_book_club/commit/5243260b9e81ef2e291ee79f3d226011dd59c142) 中，
開發人員感知運費其實相當容易變動，故事先調整程式碼的結構來應對未來的變化。
這也呼應了序章 Grady Booch 提及的 [設計模式提供新的視角](https://github.com/WadeHuang1993/design_pattern_book_club/tree/main/0.%20%E5%BA%8F%E8%A8%80#%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%96%B0%E7%9A%84%E8%A6%96%E8%A7%92)。


